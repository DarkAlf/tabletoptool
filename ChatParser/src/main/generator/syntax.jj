options {
	STATIC = false ;
	UNICODE_INPUT = true;
	//DEBUG_PARSER = true;
	//DEBUG_LOOKAHEAD = true;
	//DEBUG_TOKEN_MANAGER = true;
}
PARSER_BEGIN(ChatParser)
	package net.sf.mt2.chatparser.generated;
	
	import java.util.List;
	import java.util.LinkedList;
	import net.sf.mt2.chatparser.ChatPart;
	import net.sf.mt2.chatparser.DiceExpressionPart;
	import net.sf.mt2.chatparser.TextPart;
	import net.sf.mt2.chatparser.ChatCommand;
	import net.sf.mt2.chatparser.ChatCommandPart;
	import net.sf.mt2.dice.*;
	import net.sf.mt2.dice.expression.*;
	import java.io.BufferedReader;
	import java.io.StringReader;
	
	public class ChatParser {
		public ChatParser(String str) {
			this(new BufferedReader(new StringReader(str)));
		}
	}
PARSER_END(ChatParser)

<CHATCOMMAND>  TOKEN : { < MACRO_EXEC : "macro" | "m">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < CLEAR_CHAT : "clear" | "clr">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < EMIT : "emit" | "e">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < EMOTE : "emote" | "me">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < GM : "gm" | "togm">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < GOTO : "goto" | "g">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < IMPERSONATE : "impersonate" | "im">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < OOC : "ooc">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < REPLY : "reply" | "rep">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < ROLL : "roll" | "r">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < ROLL_GM : "rollgm" | "rgm">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < ROLL_ME : "rollme" | "rme">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < ROLL_SECRET : "rollsecret" | "rsec">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < SELF : "self">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < TABLE : "table" | "tbl">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < TOKEN_MACRO : "tmacro" | "tm">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < TOKEN_SPEECH : "tsay" | "ts">:AFTER_CC}
<CHATCOMMAND>  TOKEN : { < WHISPER : "whisper" | "w">:AFTER_CC}

<DEFAULT>  TOKEN : { < CHAT_COMMAND_SLASH : "/">:CHATCOMMAND }
<DEFAULT,AFTER_CC>  TOKEN : { < CODE_START :  "§">:DICE_EXPR }
<DEFAULT,AFTER_CC>  TOKEN : { < TEXT : ~[]> }
<DICE_EXPR>TOKEN : { < CODE_END :  "§">:AFTER_CC }
<DICE_EXPR>TOKEN : { < PLUS :  "+"> }
<DICE_EXPR>TOKEN : { < MINUS :  "-"> }
<DICE_EXPR>TOKEN : { < MULTIPLICATION :  "*"> }
<DICE_EXPR>TOKEN : { < DIVISION :  "/"> }
<DICE_EXPR>TOKEN : { < PARANTHESES_LEFT :  "("> }
<DICE_EXPR>TOKEN : { < PARANTHESES_RIGHT :  ")"> }
<DICE_EXPR>TOKEN : { < NUMBER :  (["0"-"9"])+> }

<DICE_EXPR>TOKEN : { < DICE_D : "d" > }
<DICE_EXPR>TOKEN : { < DICE_KEEP : "k" > }
<DICE_EXPR>TOKEN : { < DICE_REROLL : "r" > }
<DICE_EXPR>TOKEN : { < DICE_SUCCESS : "s" > }
<DICE_EXPR>TOKEN : { < DICE_EXPLODING_SUCCESS : "es" > }
<DICE_EXPR>TOKEN : { < DICE_EXPLODING : "e" > }
<DICE_EXPR>TOKEN : { < DICE_OPEN : "o" > }
<DICE_EXPR>TOKEN : { < DICE_HERO_STUN : "h" > }
<DICE_EXPR>TOKEN : { < DICE_HERO_BODY : "b" > }
<DICE_EXPR>TOKEN : { < DICE_FUDGE : "df" > }
<DICE_EXPR>TOKEN : { < DICE_UBIQUITY : "du" > }
<DICE_EXPR>TOKEN : { < DICE_SHADOWRUN_EXPLODING_GREMLIN : "sr4eg" > }
<DICE_EXPR>TOKEN : { < DICE_SHADOWRUN_EXPLODING : "sr4e" > }
<DICE_EXPR>TOKEN : { < DICE_SHADOWRUN_GREMLIN : "sr4g" > }
<DICE_EXPR>TOKEN : { < DICE_SHADOWRUN : "sr4" > }




List<ChatPart> Start() :
	{
		LinkedList<ChatPart> list=new LinkedList<ChatPart>();
	}
	{
		(
				<CHAT_COMMAND_SLASH>
				{ChatCommand cc;}
				cc=CHAT_COMMAND()
				<TEXT>
				{list.add(new ChatCommandPart(cc));}
		)?
		
		(
			(
				<CODE_START>
				{list.add(new DiceExpressionPart(DICE_EXPRESSION()));}
				<CODE_END>
			)
			|
			{Token t;}		  
			t=<TEXT>
			{
				if(list.getLast() instanceof TextPart)
					((TextPart)list.getLast()).append(t.image);
				else
					list.add(new TextPart(t.image));
			}
		)+
		<EOF>
		{return list;}
	}
	
ChatCommand CHAT_COMMAND() :
	{
	}
	{
		(
		    <MACRO_EXEC>
		    {return ChatCommand.MACRO_EXEC;}
		    |
			<CLEAR_CHAT>
			{return ChatCommand.CLEAR_CHAT;}
		    |
		    <EMIT>
		    {return ChatCommand.EMIT;}
		    |
		    <EMOTE>
		    {return ChatCommand.EMOTE;}
		    |
		    <GM>
		    {return ChatCommand.GM;}
		    |
		    <GOTO>
		    {return ChatCommand.GOTO;}
		    |
		    <IMPERSONATE>
		    {return ChatCommand.IMPERSONATE;}
		    |
		    <OOC>
		    {return ChatCommand.OOC;}
		    |
		    <REPLY>
		    {return ChatCommand.REPLY;}
		    |
		    <ROLL>
		    {return ChatCommand.ROLL;}
		    |
		    <ROLL_GM>
		    {return ChatCommand.ROLL_GM;}
		    |
		    <ROLL_ME>
		    {return ChatCommand.ROLL_ME;}
		    |
		    <ROLL_SECRET>
		    {return ChatCommand.ROLL_SECRET;}
		    |
		    <SELF>
		    {return ChatCommand.SELF;}
		    |
		    <TABLE>
		    {return ChatCommand.TABLE;}
		    |
		    <TOKEN_MACRO>
		    {return ChatCommand.TOKEN_MACRO;}
		    |
		    <TOKEN_SPEECH>
		    {return ChatCommand.TOKEN_SPEECH;}
		    |
		    <WHISPER>
		    {return ChatCommand.WHISPER;}
		)
	}
	

DiceExpression DICE_EXPRESSION() :
	{	}
	{
		
		{DiceExpression first=TERM();}
		(
		  	{AdditionNode a=new AdditionNode(first);}
			(				<PLUS>
				{a.add(TERM());}				|
				<MINUS>
				{a.subtract(TERM());}
			)+
			{return a;} //return Additionnode if there are at least 2 nodes
		)?
		{return first;}		  	}

DiceExpression TERM() :
	{
	}
	{
		
		{DiceExpression first=PRIMARY();}

		(
		  	{MultiplicationNode a=new MultiplicationNode(first);}
			(
				<MULTIPLICATION>
				{a.multiplyBy(PRIMARY());}
				|
				<DIVISION>
				{a.divideBy(PRIMARY());}
			)+
			{return a;} //return Multiplactionnode if there are at least 2 nodes
		)?
		{return first;}
		  
	}

DiceExpression PRIMARY():
	{
	}
	{
		(
			{int number;}
			number=NUMBER()
			(			  	{Dice d;}				d=DICE(number)				{return new DiceNode(d);}
			|
				{return new NumberNode(number);}
			)
		|
			{DiceExpression de;}
			<PARANTHESES_LEFT>
			de= DICE_EXPRESSION()
			<PARANTHESES_RIGHT>
			{return de;}
		|
			<MINUS> {return new NegationNode(PRIMARY());}
		)
	}
Dice DICE(int count) :
	{
		int type;
		int extra;
	}
	{
		(
			<DICE_FUDGE>
			{return new FudgeDice(count);}
			|
			<DICE_UBIQUITY>
			{return new UbiquityDice(count);}
			|
			<DICE_SHADOWRUN>
			{return new ShadowrunBasicDice(count);}
			|
			<DICE_SHADOWRUN_EXPLODING>
			{return new ExplodingShadowrunBasicDice(count);}
			|
			<DICE_SHADOWRUN_GREMLIN>
			extra=NUMBER()
			{return new ShadowrunGremlinDice(count,extra);}
			|
			<DICE_SHADOWRUN_EXPLODING_GREMLIN>
			extra=NUMBER()
			{return new ExplodingShadowrunGremlinDice(count,extra);}
			
		)
		| 
		(
			<DICE_D>
			type=NUMBER()
			(
				(
					<DICE_D>
					extra=NUMBER()
					{return new DropDice(count,type,extra);}
				) |
				(
					<DICE_KEEP>
					extra=NUMBER()
					{return new KeepDice(count,type,extra);}
				) |
				(
					<DICE_REROLL>
					extra=NUMBER()
					{return new RerollDice(count,type,extra);}
				) |
				(
					<DICE_SUCCESS>
					extra=NUMBER()
					{return new SuccessDice(count,type,extra);}
				) |
				(
					<DICE_EXPLODING_SUCCESS>
					extra=NUMBER()
					{return new ExplodingSuccessDice(count,type,extra);}
				) |
				(
					<DICE_EXPLODING>
					{return new ExplodingDice(count,type);}
				) |
				(
					<DICE_OPEN>
					{return new OpenDice(count,type);}
				) |
				(
					<DICE_HERO_STUN>
					{return new HeroStunDice(count,type);}
				) |
				(
					<DICE_HERO_BODY>
					{return new HeroBodyDice(count,type);}
				)
			)?
			{return new SimpleDice(count,type);}
		)
	}

int NUMBER() :
	{
		Token number;
	}
	{
		number=<NUMBER>
		{return Integer.parseInt(number.image);}	}